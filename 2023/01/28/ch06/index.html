<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"acking.cc","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Chapter 6 isolation &amp; syscallTrap 机制今天我想讨论一下，程序运行是完成用户空间和内核空间的切换。每当：  程序执行系统调用 程序出现了类似 page fault 、运算时除以 0 的错误 一个设备触发了中断使得当前程序运行需要响应内核设备驱动  都会发生这样的切换 Trap ：用户空间和内核空间的切换 系统总会频繁的切换到内核中，所以 trap 机制要尽可">
<meta property="og:type" content="article">
<meta property="og:title" content="mit6.s081-ch6">
<meta property="og:url" content="http://acking.cc/2023/01/28/ch06/index.html">
<meta property="og:site_name" content="AcKing">
<meta property="og:description" content="Chapter 6 isolation &amp; syscallTrap 机制今天我想讨论一下，程序运行是完成用户空间和内核空间的切换。每当：  程序执行系统调用 程序出现了类似 page fault 、运算时除以 0 的错误 一个设备触发了中断使得当前程序运行需要响应内核设备驱动  都会发生这样的切换 Trap ：用户空间和内核空间的切换 系统总会频繁的切换到内核中，所以 trap 机制要尽可">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304020140746.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304020426371.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304020452675.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304020622313.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304020635391.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304020656731.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304020725526.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304020753530.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304020813660.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304021050514.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304085159639.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304085251190.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304102125562.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304102143159.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304102226036.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304102532719.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304102644227.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304102700097.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304103134450.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304103419959.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304103532426.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304103603251.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104009495.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104045039.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104101258.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104155385.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104210332.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104239186.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104355536.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104429488.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104450725.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104505409.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104548581.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104616898.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104752934.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104812798.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104823029.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104846355.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104917288.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104928779.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304105043494.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304105057200.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304105139151.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304105152631.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304105214655.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304105308767.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304105340881.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304105546413.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304105638012.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304105707488.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304105840754.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304105932915.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304110045221.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304110411221.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304110421371.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304110453852.png">
<meta property="og:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304110507023.png">
<meta property="article:published_time" content="2023-01-27T16:00:00.000Z">
<meta property="article:modified_time" content="2023-01-28T12:36:27.191Z">
<meta property="article:author" content="Sam Shen">
<meta property="article:tag" content="mit6.s081">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304020140746.png">

<link rel="canonical" href="http://acking.cc/2023/01/28/ch06/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>mit6.s081-ch6 | AcKing</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">AcKing</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">for dreams</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="en fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="en fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="en fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="en fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="en fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://acking.cc/2023/01/28/ch06/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/1.jpg">
      <meta itemprop="name" content="Sam Shen">
      <meta itemprop="description" content="share cs knowledge">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AcKing">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/mit6.s081-ch6" class="post-title-link post-title-link-external" itemprop="url">mit6.s081-ch6<i class="fa fa-external-link-alt"></i></a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-01-28 00:00:00 / Modified: 20:36:27" itemprop="dateCreated datePublished" datetime="2023-01-28T00:00:00+08:00">2023-01-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mit6-s081/" itemprop="url" rel="index"><span itemprop="name">mit6.s081</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mit6-s081/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Chapter-6-isolation-amp-syscall"><a href="#Chapter-6-isolation-amp-syscall" class="headerlink" title="Chapter 6 isolation &amp; syscall"></a>Chapter 6 isolation &amp; syscall</h1><h3 id="Trap-机制"><a href="#Trap-机制" class="headerlink" title="Trap 机制"></a>Trap 机制</h3><p>今天我想讨论一下，程序运行是<strong>完成用户空间和内核空间的切换</strong>。每当：</p>
<ul>
<li>程序执行系统调用</li>
<li>程序出现了类似 page fault 、运算时除以 0 的错误</li>
<li>一个设备触发了中断使得当前程序运行需要响应内核设备驱动</li>
</ul>
<p>都会发生这样的切换</p>
<p><strong>Trap</strong> ：用户空间和内核空间的切换</p>
<p><strong>系统总会频繁的切换到内核中，所以 trap 机制要尽可能的简单</strong>。</p>
<p>在这个 trap 过程中，硬件的状态非常重要，因为我们很多的工作都是将硬件从适合运行用户应用程序的状态，改变到适合运行内核代码的状态。</p>
<p>我们最关心的状态可能是 32 个用户寄存器。RISC-V 总共有 32 个寄存器，用户应用程序可以使用全部的寄存器（使用寄存器的指令性能是最好的）。</p>
<ul>
<li>在硬件中有一个寄存器叫做程序计数器 PC（Program Counter Register）</li>
<li>mode 表明当前 mode 的标志位，这个标志位表明了当前是 supervisor mode 还是 user mode。当我们在运行 Shell 的时候，自然是在 user mode</li>
<li>还有一堆控制 CPU 工作方式的寄存器，比如 SATP 寄存器，它包含了指向 page table 的物理内存地址。</li>
<li>还有一些对于今天讨论非常重要的寄存器，比如 STVEC（Supervisor Trap Vector Base Address Register）寄存器，它指向了内核中专门处理 trap 的指令的程序的起始地址。</li>
<li>SEPC（Supervisor Exception Program Counter）寄存器，在 trap 的过程中保存程序计数器的值。</li>
</ul>
<p>在 trap 的最开始，CPU 的所有状态都设置成运行用户代码而不是内核代码。在 trap 处理的过程中，我们实际上需要更改一些这里的状态，或者对状态做一些操作。这样我们才可以运行系统内核中的 C 程序。</p>
<p>接下来我们先来预览一下需要做的操作：</p>
<ul>
<li><p>我们需要保存 32 个用户寄存器。（很显然我们需要恢复用户应用程序的执行，尤其是当用户程序随机的被设备中断所打断时。我们希望内核能够响应中断，之后在用户程序完全无感知的情况下再恢复用户代码的执行。）</p>
</li>
<li><p>程序计数器也需要在某个地方保存，它几乎跟一个用户寄存器的地位是一样的，我们需要能够在用户程序运行中断的位置继续执行用户程序。</p>
</li>
<li><p>我们需要将 mode 切换到 supervisor mode，因为我们想要使用内核中的各种各样的特权指令。</p>
</li>
<li><p>SATP 寄存器现在正指向 user page table，而 user page table 只包含了用户程序所需要的内存映射和一两个其他的映射，它并没有包含整个内核数据的内存映射。所以在运行内核代码之前，我们需要将 SATP 指向 kernel page table。</p>
</li>
<li><p>我们需要将堆栈寄存器指向位于内核的一个地址，因为我们需要一个堆栈来调用内核的 C 函数。</p>
<blockquote>
<p>这里应该是要调用 SP、FP 等指针。</p>
</blockquote>
</li>
<li><p>一旦我们设置好了，并且所有的硬件状态都适合在内核中使用， 我们需要跳入内核的 C 代码。</p>
</li>
<li><p>一旦我们运行在内核的 C 代码中，那就跟平常的 C 代码是一样的。</p>
</li>
</ul>
<h4 id="安全和隔离"><a href="#安全和隔离" class="headerlink" title="安全和隔离"></a>安全和隔离</h4><p>我们不想让用户代码介入到这里的 <code>user/kernel</code> 切换，否则有可能会破坏安全性。<strong>所以这意味着，trap 中涉及到的硬件和内核机制不能依赖任何来自用户空间东西。</strong>比如说我们不能依赖 32 个用户寄存器，它们可能保存的是恶意的数据，所以，XV6 的 trap 机制不会查看这些寄存器，而只是将它们保存起来。</p>
<blockquote>
<p>出于安全性考虑，XV6 的 trap 机制只会保存 32 个寄存器，而不查看其之前的内容。</p>
</blockquote>
<p>在操作系统的 trap 机制中，我们仍然想保留隔离性并防御来自用户代码的可能恶意攻击。同样也很重要的是，我们想要让 trap 机制对用户代码是透明的，也就是说我们想要执行 trap，然后在内核中执行代码，同时用户代码并不用察觉到任何事情，这样也更容易写用户代码。</p>
<blockquote>
<p>user 到 kernel 的切换过程需要安全，kernel 内部也要保证安全。</p>
</blockquote>
<p><strong>有一点很重要：当这个标志位从 user mode 变更到 supervisor mode 时，我们能得到什么样的权限。实际上，这里获得的额外权限实在是有限。也就是说，你可以在 supervisor mode 完成，但是不能在 user mode 完成的工作，或许并没有你想象的那么有特权。</strong>所以，我们接下来看看 supervisor mode 可以控制什么？</p>
<p>其中的一件事情是，你现在可以读写控制寄存器了。比如说，当你在 supervisor mode 时，你可以：</p>
<ul>
<li>读写 SATP 寄存器，也就是 page table 的指针；</li>
<li>STVEC，也就是处理 trap 的内核指令地址；</li>
<li>SEPC，保存当发生 trap 时的程序计数器；</li>
<li>SSCRATCH 寄存器等等。</li>
</ul>
<p><strong>在 supervisor mode 你可以读写这些寄存器，而用户代码不能做这样的操作。</strong></p>
<p>另一件事情 supervisor mode 可以做的是，它可以使用 PTE_U 标志位为 0 的 PTE。当 PTE_U 标志位为 1 的时候，表明用户代码可以使用这个页表；如果这个标志位为 0，则只有 supervisor mode 可以使用这个页表。我们接下来会看一下为什么这很重要。</p>
<p><strong>这两点就是 supervisor mode 可以做的事情，除此之外就不能再干别的事情了。</strong></p>
<blockquote>
<p>总结，内核态就多了两点，第一是可以读写一些控制寄存器，第二是可以使用 PTE_U 为 0 的页表项。</p>
</blockquote>
<p>需要特别指出的是，supervisor mode 中的代码并不能读写任意物理地址。<strong>在 supervisor mode 中，就像普通的用户代码一样，也需要通过 page table 来访问内存。如果一个虚拟地址并不在当前由 SATP 指向的 page table 中，又或者 SATP 指向的 page table 中 <code>PTE_U = 1</code>，那么 supervisor mode 不能使用那个地址。</strong>所以，即使我们在 supervisor mode，我们还是受限于当前 page table 设置的虚拟地址。</p>
<h3 id="Trap-代码执行流程"><a href="#Trap-代码执行流程" class="headerlink" title="Trap 代码执行流程"></a>Trap 代码执行流程</h3><p>这节课大部分时间都会通过 gdb 来跟踪代码是如何通过 trap 进入到内核空间，这里会涉及到很多的细节。为了帮助你提前了解接下来的内容，我们会跟踪如何在 shell 中调用 write 系统调用。从 Shell 的角度来说，这就是个 Shell 代码中的 C 函数调用，但是实际上，write 通过执行 <code>ECALL</code> 指令来执行系统调用。<code>ECALL</code> 指令会切换到具有 supervisor mode 的内核中。在这个过程中，内核中执行的第一个指令是一个由汇编语言写的函数，叫做 <code>uservec</code>。这个函数是内核代码 <code>trampoline.s</code> 文件的一部分。所以执行的第一个代码就是这个 <code>uservec</code> 汇编函数。之后，在这个汇编函数中，代码执行跳转到了由 C 语言实现的函数 <code>usertrap</code> 中，这个函数在 <code>trap.c</code> 中。现在代码运行在 C 中，所以代码更加容易理解。在 <code>usertrap</code> 这个 C 函数中，我们执行了一个叫做 <code>syscall</code> 的函数。</p>
<p>这个函数会在一个表单中，根据传入的代表系统调用的数字进行查找，并在内核中执行具体实现了系统调用功能的函数。对于我们来说，这个函数就是 <code>sys_write</code>。</p>
<p><code>sys_write</code> 会将要显示数据输出到 <code>console</code> 上，当它完成了之后，它会返回给<code>syscall</code> 函数。</p>
<p>因为我们现在相当于在 <code>ECALL</code> 之后中断了用户代码的执行，为了用户空间的代码恢复执行，需要做一系列的事情。在 <code>syscall</code> 函数中，会调用一个函数叫做 <code>usertrapret</code> ，它也位于 <code>trap.c</code> 中，这个函数完成了部分方便在 C 代码中实现的返回到用户空间的工作。</p>
<p>除此之外，最终还有一些工作只能在汇编语言中完成。这部分工作通过汇编语言实现，并且存在于 <code>trampoline.s</code> 文件中的 <code>userret</code> 函数中。</p>
<p>最终，在这个汇编函数中会调用机器指令返回到用户空间，并且恢复 ECALL 之后的用户程序的执行。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304020140746.png" alt="image-20220304020140746"></p>
<p>对于这里的概述大家有问题吗？没有的话我要切到 gdb 了。</p>
<blockquote>
<p>学生提问：难道 <code>vm.c</code> 中的函数不是要直接访问物理内存吗？</p>
<p>Robert教授：是的，这些函数能这么做的原因是，内核小心地在 page table 中设置好了各个 PTE。这样当内核收到了一个读写虚拟内存地址的请求，会通过 kernel page table 将这个虚拟内存地址翻译成与之等价物理内存地址，再完成读写。所以，一旦使用了 kernel page table，就可以非常方便的在内核中使用所有这些直接的映射关系。但是直到 trap 机制切换到内核之前，这些映射关系都不可用。直到 trap 机制将程序运行切换到内核空间之前，我们使用的仍然是没有这些方便映射关系的 user page table。</p>
<p>学生提问：这个问题或许并不完全相关，read 和 write 系统调用，相比内存的读写，他们的代价都高的多，因为它们需要切换模式，并来回折腾。有没有可能当你执行打开一个文件的系统调用时， 直接得到一个 page table 映射，而不是返回一个文件描述符？这样只需要向对应于设备的特定的地址写数据，程序就能通过 page table 访问特定的设备。你可以设置好限制，就像文件描述符只允许修改特定文件一样，这样就不用像系统调用一样在用户空间和内核空间来回捣腾了。</p>
<p>Robert教授：这是个很好的想法，实际上很多操作系统都提供这种叫做内存映射文件（Memory-mapped file access）的机制，在这个机制里面通过 page table，可以将用户空间的虚拟地址空间，对应到文件内容，这样你就可以通过内存地址直接读写文件。实际上，你们将在 mmap 实验中完成这个机制。对于许多程序来说，这个机制的确会比直接调用 read&#x2F;write 系统调用要快的多。</p>
</blockquote>
<h3 id="ECALL-指令之前的状态"><a href="#ECALL-指令之前的状态" class="headerlink" title="ECALL 指令之前的状态"></a>ECALL 指令之前的状态</h3><p>我们将要跟踪一个 XV6 的系统调用，也就是 shell 将它的提示信息通过 write 系统调用走到操作系统再输出到 console 的过程。你们可以看到，用户代码 <code>sh.c</code> 初始了这一切。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304020426371.png" alt="img"></p>
<p>上图中选中的行，是一个 write 系统调用，它将 <code>$ </code> 写入到文件描述符 2。接下来我将打开 gdb 并启动 XV6。</p>
<p>作为用户代码的 Shell 调用 write 时，<strong>实际上调用的是关联到 Shell 的一个库函数。</strong>你可以查看这个库函数的源代码，在 <code>usys.s</code>。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304020452675.png" alt="img"></p>
<p>上面这几行代码就是实际被调用的 write 函数的实现。这是个非常短的函数：</p>
<ul>
<li>首先将 <code>SYS_write</code> 加载到 <code>a7</code> 寄存器，<code>SYS_write</code> 是常量16。这里告诉内核，我想要运行第 16 个系统调用，而这个系统调用正好是 write 。</li>
<li>之后这个函数中执行了 ecall 指令，<strong>从这里开始代码执行跳转到了内核。</strong>内核完成它的工作之后，代码执行会返回到用户空间，继续执行 ecall 之后的指令，也就是 ret ，最终返回到 Shell 中。所以  ret 从 write 库函数返回到了 Shell 中。</li>
</ul>
<p>为了展示这里的系统调用，我会在 ecall 指令处放置一个断点，为了能放置断点，我们需要知道 ecall 指令的地址，我们可以通过查看由 XV6 编译过程产生的 <code>sh.asm</code> 找出这个地址。<code>sh.asm</code> 是带有指令地址的汇编代码（注，asm文件3.7有介绍）。我这里会在 ecall 指令处放置一个断点，这条指令的地址是 <code>0xde6</code> 。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304020622313.png" alt="img"></p>
<p>现在，我要让 XV6 开始运行。我期望的是 XV6 在 Shell 代码中正好在执行 ecall 之前就会停住。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304020635391.png" alt="img"></p>
<p>完美，从gdb可以看出，我们下一条要执行的指令就是 ecall。我们来检验一下我们真的在我们以为自己在的位置，让我们来打印程序计数器 PC 正好我们期望在的位置 <code>0xde6</code>。</p>
<p>我们还可以输入 <code>info reg</code> 打印全部 32 个用户寄存器，</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304020656731.png" alt="img"></p>
<p>这里有一些数值我们还不知道，也不关心，<strong>但是这里的 a0，a1，a2 是 Shell 传递给 write 系统调用的参数：</strong></p>
<ul>
<li>a0 是文件描述符 2；</li>
<li>a1 是 Shell 想要写入字符串的指针；</li>
<li>a2 是想要写入的字符数。我们还可以通过打印 Shell 想要写入的字符串内容，来证明断点停在我们认为它应该停在的位置。</li>
</ul>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304020725526.png" alt="img"></p>
<p>可以看出，输出的确是 <code>$</code> 和空格。所以，我们现在位于我们期望所在的 <code>write</code> 系统调用函数中。</p>
<blockquote>
<p>上图的寄存器中，程序计数器（pc）和堆栈指针（sp）的地址现在都在距离 0 比较近的地址，这进一步印证了当前代码运行在用户空间，因为用户空间中所有的地址都比较小。但是一旦我们进入到了内核，内核会使用大得多的内存地址。</p>
</blockquote>
<p>其中一个最重要的需要变更的状态，并且在它变更之前我们对它还有依赖的，就是是当前的 page table。我们可以查看 STAP 寄存器。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304020753530.png" alt="img"></p>
<p>这里输出的是物理内存地址，它并没有告诉我们有关 page table 中的映射关系是什么，page table 长什么样。</p>
<blockquote>
<p>在  QEMU 中有一个方法可以打印当前的 page table。从 QEMU 界面，输入 <code>ctrl a + c</code>  可以进入到 QEMU 的 console，之后输入 <code>info mem</code>，QEMU 会打印完整的 page table。</p>
</blockquote>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304020813660.png" alt="img"></p>
<blockquote>
<p>这是个非常小的 page table，它只包含了 6 条映射关系。这是用户程序 shell 的 page table，而 shell 是一个非常小的程序，这 6 条映射关系是有关 shell 的指令和数据，以及一个无效的 page 用来作为 guard page，以防止 Shell 尝试使用过多的 stack page。我们可以看出这个 page 是无效的，因为在 attr 这一列它并没有设置u标志位（第三行）。<strong>attr 这一列是 PTE 的标志位，第三行的标志位是 rwx 表明这个 page 可以读，可以写，也可以执行指令。之后的是 u 标志位，它表明 PTE_U 标志位是否被设置，用户代码只能访问 PTE_U 标志位设置了的PTE。</strong>再下一个标志位我也不记得是什么了（注，从 4.3 可以看出，这个标志位是Global）。再下一个标志位是 a（Accessed），表明这条PTE是不是被使用过，再下一个标志位d（Dirty）表明这条 PTE 是不是被写过。</p>
</blockquote>
<p>现在，我们有了这个小小的 page table。顺便说一下，最后两条 PTE 的虚拟地址非常大，非常接近虚拟地址的顶端，如果你读过了 XV6 的书，你就知道这两个 page 分别是 trapframe page 和 trampoline page。你可以看到，它们都没有设置 u 标志，所以用户代码不能访问这两条 PTE。一旦我们进入到了 supervisor mode，我们就可以访问这两条 PTE 了。</p>
<p>对于这里 page table，<strong>它并没有包含任何内核部分的地址映射，这里既没有对于 kernel data 的映射，也没有对于 kernel 指令的映射。</strong>除了最后两条 PTE，这个 page table 几乎是完全为用户代码执行而创建，所以它对于在内核执行代码并没有直接特殊的作用。</p>
<blockquote>
<p>学生提问：PTE中 a 标志位是什么意思？</p>
<p>Robert教授：这表示这条PTE是不是被代码访问过，是不是曾经有一个被访问过的地址包含在这个PTE的范围内。d 标志位表明是否曾经有写指令使用过这条PTE。这些标志位由硬件维护以方便操作系统使用。对于比 XV6 更复杂的操作系统，当物理内存吃紧的时候，可能会通过将一些内存写入到磁盘来，同时将相应的PTE 设置成无效，来释放物理内存 page。你可以想到，这里有很多策略可以让操作系统来挑选哪些 page 可以释放。我们可以查看 a 标志位来判断这条PTE是否被使用过，如果它没有被使用或者最近没有被使用，那么这条 PTE 对应的 page 适合用来保存到磁盘中。类似的，D 标志位告诉内核，这个 page 最近被修改过。不过 XV6 没有这样的策略。</p>
</blockquote>
<p>接下来，我会在 Shell 中打印出 write 函数的内容。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304021050514.png" alt="img"></p>
<p>程序计数器现在指向 ecall 指令，我们接下来要执行 ecall 指令。现在我们还在用户空间，但是马上我们就要进入内核空间了。</p>
<h3 id="ECALL-指令之后的状态"><a href="#ECALL-指令之后的状态" class="headerlink" title="ECALL 指令之后的状态"></a>ECALL 指令之后的状态</h3><p>现在我执行 <code>ecall</code> 指令：</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304085159639.png" alt="image-20220304085159639"></p>
<p>第一个问题，执行完了 <code>ecall</code> 之后我们现在在哪？我们可以打印 PC 来查看。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304085251190.png" alt="img"></p>
<p>可以看到程序计数器的值变化了，之前我们的程序计数器还在一个很小的地址 <code>0xde6</code>，但是现在在一个大得多的地址。我们还可以查看 page table，我通过在 QEMU 中执行 <code>info mem</code> 来查看当前的 page table，可以看出，这还是与之前完全相同的 page table，所以 page table 没有改变。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304102125562.png" alt="img"></p>
<p>根据现在的程序计数器，代码正在 trampoline page 的最开始，这是用户内存中一个非常大的地址。所以现在我们的指令正运行在内存的 trampoline page 中，我们可以来查看一下现在将要运行的指令。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304102143159.png" alt="img"></p>
<blockquote>
<p>这些指令是内核在 supervisor mode 中将要执行的最开始的几条指令，也是在 trap 机制中最开始要执行的几条指令。因为 gdb 有一些奇怪的行为，我们实际上已经执行了位于 trampoline page 最开始的一条指令（注，也就是 <code>csrrw</code> 指令，交换了寄存器 a0 和 sscratch 的内容），我们将要执行的是第二条指令。</p>
<p>我们可以查看寄存器，寄存器的值并没有改变，这里还是用户程序拥有的一些寄存器内容。</p>
</blockquote>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304102226036.png" alt="img"></p>
<p>现在寄存器里面还都是用户程序的数据，并且这些数据也还只保存在这些寄存器中，所以我们需要非常小心，在将寄存器数据保存在某处之前，我们在这个时间点不能使用任何寄存器，否则的话我们是没法恢复寄存器数据的。如果内核在这个时间点使用了任何一个寄存器，内核会覆盖寄存器内的用户数据，之后如果我们尝试要恢复用户程序，我们就不能恢复寄存器中的正确数据，用户程序的执行也会相应的出错。</p>
<blockquote>
<p>学生提问：我想知道 <code>csrrw</code> 指令是干什么的？</p>
<p>Robert教授：我们过几分钟会讨论这部分，这条指令交换了寄存器 a0 和 sscratch 的内容。这个操作超级重要，它回答了这个问题，内核的 trap 代码如何能够在不使用任何寄存器的前提下做任何操作。这条指令将 a0 的数据保存在了 sscratch 中，同时又将 sscratch 内的数据保存在 a0 中。之后内核就可以任意的使用 a0 寄存器了。</p>
</blockquote>
<p>我们现在在这个地址 <code>0x3ffffff000</code>，也就是上面 page table 输出的最后一个 page，这是 trampoline page。我们现在正在 trampoline page 中执行程序，这个 page 包含了内核的 trap 处理代码。<strong>ECALL 并不会切换page table，这是ecall指令的一个非常重要的特点。所以这意味着，trap 处理代码必须存在于每一个 user page table 中。因为 ecall 并不会切换 page table，我们需要在 user page table 中的某个地方来执行最初的内核代码。而这个 trampoline page，是由内核小心的映射到每一个 user page table 中的，以使得当我们仍然在使用user page table 时，内核在一个地方能够执行 trap 机制的最开始的一些指令。</strong></p>
<blockquote>
<p>总结一下，ecall 指令并不会切换 page table，所以需要在用户态下，执行最开始的一些 kernel 指令。</p>
</blockquote>
<p>这里的控制是通过 STVEC 寄存器完成的，这是一个只能在 supervisor mode 下读写的特权寄存器。在从用户空间进入到内核空间之前，内核会设置好 STVEC 寄存器指向内核希望 trap 代码运行的位置。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304102532719.png" alt="img"></p>
<p>如你所见，内核已经事先设置好了 STVEC 寄存器的内容为 <code>0x3ffffff000</code>，这就是 trampoline page 的起始位置。STVEC 寄存器的内容，就是在 ecall 指令执行之后，我们会在这个特定地址执行指令的原因。</p>
<blockquote>
<p>即使 trampoline page 是在用户地址空间的 user page table 完成的映射，用户代码也不能写它，因为这些 page 对应的 PTE 并没有设置 PTE_U 标志位。这也是 trap 机制是安全的原因。</p>
</blockquote>
<p><strong>我一直在告诉你们我们现在已经在 supervisor mode 了，但是实际上我并没有任何能直接确认当前在哪种 mode 下的方法。不过我的确发现程序计数器现在正在 trampoline page 执行代码，而这些 page 对应的 PTE 并没有设置 PTE_U 标志位。所以现在只有当代码在 supervisor mode 时，才可能在程序运行的同时而不崩溃。所以，我从代码没有崩溃和程序计数器的值推导出我们必然在 supervisor mode。</strong></p>
<p>我们是通过 ecall 走到 trampoline page 的，而 ecall 实际上只会改变三件事情：</p>
<ul>
<li><p>ecall 将代码从 user mode 改到 supervisor mode；</p>
</li>
<li><p>ecall 将程序计数器的值保存在了 SEPC 寄存器，我们可以通过打印程序计数器看到这里的效果；</p>
</li>
</ul>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304102644227.png" alt="img"></p>
<p>尽管其他的寄存器还是还是用户寄存器，但是这里的程序计数器明显已经不是用户代码的程序计数器。这里的程序计数器 PC 是从 STVEC 寄存器拷贝过来的值。我们也可以打印 SEPC 寄存器，这是 ecall 保存用户程序计数器的地方。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304102700097.png" alt="img"></p>
<p>这个寄存器里面有熟悉的地址 <code>0xde6</code>，这是 ecall 指令在用户空间的地址。所以 ecall 至少保存了程序计数器的数值。</p>
<ul>
<li>ecall 会跳转到 STVEC 寄存器指向的指令</li>
</ul>
<p>所以现在，ecall 帮我们做了一点点工作，但是实际上我们离执行内核中的 C 代码还差的很远，接下来：</p>
<ul>
<li>我们需要保存 32 个用户寄存器的内容，方便后续恢复；</li>
<li>需要切换到 kernel page table；</li>
<li>我们需要创建或者找到一个 kernel stack，并将 stack Pointer 寄存器的内容指向那个 kernel stack，这样才能给 C 代码提供栈；</li>
<li>我们还需要跳转到内核中 C 代码的某些合理的位置。</li>
</ul>
<p>ecall 并不会为我们做这里的任何一件事。所以你现在可能会问，为什么 ecall 不多做点工作来将代码执行从用户空间切换到内核空间呢？为什么 ecall 不会保存用户寄存器，或者切换 page table 指针来指向 kernel page table，或者自动的设置 Stack Pointer 指向 kernel stack，或者直接跳转到 kernel的 C 代码，而不是在这里运行复杂的汇编代码？</p>
<p>实际上，有的机器在执行系统调用时，会在硬件中完成所有这些工作。但是 RISC-V 并不会，RISC-V 秉持了这样一个观点：ecall 只完成尽量少必须要完成的工作，其他的工作都交给软件完成。<strong>这里的原因是，RISC-V 设计者想要为软件和操作系统的程序员提供最大的灵活性，这样他们就能按照他们想要的方式开发操作系统。</strong></p>
<p>下面举几个例子，说明为什么 XV6 中 ecall 这里很简单：</p>
<ul>
<li>因为这里的 ecall 是如此的简单，或许某些操作系统可以在不切换 page table 的前提下，执行部分系统调用。切换 page table 的代价比较高，如果 ecall 打包完成了这部分工作，那就不能对一些系统调用进行改进，使其不用在不必要的场景切换 page table。</li>
<li>某些操作系统同时将 user 和 kernel 的虚拟地址映射到一个 page table 中，这样在 user 和 kernel 之间切换时根本就不用切换 page table。对于这样的操作系统来说，如果 ecall 切换了 page table 那将会是一种浪费，并且也减慢了程序的运行。</li>
<li>或许在一些系统调用过程中，一些寄存器不用保存，而哪些寄存器需要保存，哪些不需要，取决于软件，编程语言，和编译器。通过不保存所有的 32 个寄存器或许可以节省大量的程序运行时间，所以你不会想要 ecall 迫使你保存所有的寄存器。</li>
<li>最后，对于某些简单的系统调用或许根本就不需要任何 stack，所以对于一些非常关注性能的操作系统，ecall 不会自动为你完成 stack 切换是极好的。</li>
</ul>
<blockquote>
<p>学生提问：为什么我们在 gdb 中看不到 ecall 的具体内容？我觉得我们是直接跳到 trampoline 代码的。</p>
<p>Robert教授：ecall 只会更新 CPU 中的 mode 标志位为 supervisor，并且设置程序计数器成 STVEC 寄存器内的值。在进入到用户空间之前，内核会将 trampoline page 的地址存在 STVEC 寄存器中。所以 ecall 的下一条指令的位置是 STVEC 指向的地址，也就是 trampoline page 的起始地址。</p>
<p><strong>此注释中的这些步骤：切换 mode 、将 PC 设置成 STVEC 中的值、跳转到 PC 指向的位置。这三步一气呵成，实际上 ecall 是 CPU 的指令，自然在gdb中看不到具体内容。</strong></p>
</blockquote>
<h3 id="uservec-函数"><a href="#uservec-函数" class="headerlink" title="uservec 函数"></a>uservec 函数</h3><p>回到 XV6 和 RISC-V，现在程序位于 trampoline page 的起始，也是 uservec 函数的起始。我们现在需要做的第一件事情就是保存寄存器的内容。在 RISC-V 上，如果不能使用寄存器，基本上不能做任何事情。所以，对于保存这些寄存器，我们有什么样的选择呢？</p>
<p>在一些其他的机器中，我们或许直接就将 32 个寄存器中的内容写到物理内存中某些合适的位置。但是我们不能在 RISC-V 中这样做，因为在RISC-V中，supervisor mode 下的代码不允许直接访问物理内存。所以<strong>我们只能使用 page table 中的内容</strong>，但是从前面的输出来看，page table 中也没有多少内容。</p>
<p>虽然 XV6 并没有使用，但是另一种可能的操作是，直接将 SATP 寄存器指向 kernel page table，之后我们就可以直接使用所有的 kernel mapping 来帮助我们存储用户寄存器。这是合法的，因为 supervisor mode 可以更改 SATP 寄存器。</p>
<p>但是在 trap 代码当前的位置，也就是 trap 机制的最开始，我们并不知道 kernel page table 的地址。并且，更改 SATP 寄存器的指令，要求写入 SATP 寄存器的内容来自于另一个寄存器。所以，为了能执行更新 page table 的指令，我们需要一些空闲的寄存器，这样我们才能先将 page table 的地址存在这些寄存器中，然后再执行修改SATP寄存器的指令。</p>
<blockquote>
<p>总结，一是没有空闲的寄存器，二是一开始不知道 kernel page table 的地址，导致没办法直接将 SATP 指向 kernel page table。</p>
</blockquote>
<p>对于保存用户寄存器，XV6 在 RISC-V 上的实现包括了两个部分。</p>
<p>第一个部分是，XV6 在每个 user page table 映射了 trapframe page，这样每个进程都有自己的 trapframe page。这个 page 包含了很多有趣的数据，但是现在最重要的数据是用来保存用户寄存器的 32 个空槽位。所以，在 trap 处理代码中，现在的好消息是，我们在 user page table 有一个之前由 kernel 设置好的映射关系，这个映射关系指向了一个可以用来存放这个进程的用户寄存器的内存位置。这个位置的虚拟地址总是 <code>0x3ffffffe000</code>。</p>
<p>如果你想查看 XV6 在 trapframe page 中存放了什么，这部分代码在 <code>proc.h</code> 中的 trapframe 结构体中。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304103134450.png" alt="img"></p>
<p>你可以看到很多槽位的名字都对应了特定的寄存器。在最开始还有 5 个数据，这些是内核事先存放在 trapframe 中的数据。比如第一个数据保存了 kernel page table 地址，这将会是 trap 处理代码将要加载到 SATP 寄存器的数值。</p>
<p>所以，如何保存用户寄存器的一半答案是，内核非常方便的将 trapframe page 映射到了每个 user page table。</p>
<p>另一半的答案在于我们之前提过的 SSCRATCH 寄存器。在进入到 user space 之前，内核会将 trapframe page 的地址保存在这个寄存器中，也就是 <code>0x3fffffe000</code> 这个地址。更重要的是，RISC-V 有一个指令允许交换任意两个寄存器的值。而 SSCRATCH 寄存器的作用就是保存另一个寄存器的值，并将自己的值加载给另一个寄存器。如果我查看 <code>trampoline.S</code> 代码：</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304103419959.png" alt="img"></p>
<p>第一件事情就是执行 csrrw 指令，这个指令交换了 a0 和 sscratch 两个寄存器的内容。为了看这里的实际效果，我们来打印 a0，</p>
<p>a0现在的值是 <code>0x3fffffe000</code>，这是 trapframe page 的虚拟地址。它之前保存在 SSCRATCH 寄存器中，但是我们现在交换到了 a0 中。我们也可以打印 SSCRATCH 寄存器，</p>
<p>它现在的内容是 2，这是 a0 寄存器之前的值。a0 寄存器保存的是 write 函数的第一个参数，在这个场景下，是 Shell 传入的文件描述符2。所以我们现在将 a0 的值保存起来了，并且我们有了指向 trapframe page 的指针。现在我们正在朝着保存用户寄存器的道路上前进。实际上，这就是 <code>trampoline.S</code> 中接下来 30多个奇怪指令的工作。这些指令就是的执行 <code>sd</code>，将每个寄存器保存在 <code>trapframe</code> 的不同偏移位置。因为 <code>a0</code> 在交换完之后包含的是 <code>trapframe page</code> 地址，也就是 <code>0x3fffffe000</code>。所以，每个寄存器被保存在了 <code>偏移量 + a0 </code> 的位置。</p>
<blockquote>
<p>学生提问：当与 a0 寄存器进行交换时，trapframe 的地址是怎么出现在 SSCRATCH 寄存器中的？</p>
<p>Robert教授：<strong>在内核前一次切换回用户空间时，内核会执行 <code>set sscratch</code> 指令，将这个寄存器的内容设置为 <code>0x3fffffe000</code>，也就是 trapframe page 的虚拟地址。</strong>所以，当我们在运行用户代码，比如运行 Shell 时，SSCRATCH 保存的就是指向 trapframe 的地址。之后，Shell 执行了 ecall 指令，跳转到了 trampoline page，这个 page 中的第一条指令会交换 a0 和 SSCRATCH 寄存器的内容。所以，SSCRATCH 中的值，也就是指向 trapframe 的指针现在存储于 a0 寄存器中。</p>
<p>同一个学生提问：这是发生在进程创建的过程中吗？这个 SSCRATCH 寄存器存在于哪？</p>
<p>Robert教授：这个寄存器存在于 CPU 上，这是 CPU 上的一个特殊寄存器。内核在什么时候设置的它呢？这有点复杂。它被设置的实际位置，我们可以看下图，</p>
</blockquote>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304103532426.png"></p>
<blockquote>
<p>选中的代码是内核在返回到用户空间之前执行的最后两条指令。在内核返回到用户空间时，会恢复所有的用户寄存器。之后会再次执行交换指令，csrrw。因为之前内核已经设置了 a0 保存的是 trapframe 地址，经过交换之后 SSCRATCH 仍然指向了 trapframe page 地址，而 a0 也恢复成了之前的数值。最后 sret 返回到了用户空间。</p>
<p>你或许会好奇，a0 是如何有 trapframe page 的地址。我们可以查看 <code>trap.c</code> 代码，</p>
</blockquote>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304103603251.png" alt="img"></p>
<blockquote>
<p>这是内核返回到用户空间的最后的C函数，C 函数做的最后一件事情是调用 fn 函数，传递的参数是TRAMFRAME 和 user page table。在C代码中，当你调用函数，第一个参数会存在 a0，这就是为什么 a0 里面的数值是指向 trapframe 的指针。fn 函数是就是刚刚我向你展示的位于 <code>trampoline.S</code> 中的代码。</p>
<p>学生提问：当你启动一个进程，之后进程在运行，之后在某个时间点进程执行了 ecall 指令，那么你是在什么时候执行上一个问题中的 fn 函数呢？因为这是进程的第一个 ecall 指令，所以这个进程之前应该没有调用过fn函数吧。</p>
<p>Robert教授：一台机器总是从内核开始运行的，当机器启动的时候，它就是在内核中，任何时候，不管是进程第一次启动还是从一个系统调用返回，进入到用户空间的唯一方法是就是执行 sret 指令。sret 指令是由RISC-V 定义的用来从 supervisor mode 转换到 user mode。所以，在任何用户代码执行之前，内核会执行 fn 函数，并设置好所有的东西，例如 SSCRATCH，STVEC 寄存器。</p>
<p>学生提问：当我们在汇编代码中执行 ecall 指令，是什么触发了 trampoline 代码的执行，是 CPU 中的从user 到 supervisor 的标志位切换吗？</p>
<p>Robert教授：在我们的例子中，Shell在用户空间执行了ecall指令。ecall会完成几件事情，ecall指令会设置当前为 supervisor mode，保存程序计数器到SEPC寄存器，并且将程序计数器设置成控制寄存器 STVEC 的内容。STVEC 是内核在进入到用户空间之前设置好的众多数据之一，内核会将其设置成 trampoline page 的起始位置。所以，当 ecall 指令执行时，ecall 会将 STVEC 拷贝到程序计数器，之后程序继续执行，但是却会在当前程序计数器所指的地址，也就是 trampoline page 的起始地址执行。</p>
<p>学生提问：寄存器保存在了 trapframe page，但是这些寄存器用户程序也能访问，为什么我们要使用内存中一个新的区域（指的是trapframe page），而不是使用程序的栈？</p>
<p>Robert教授：好的，这里或许有两个问题。第一个是，为什么我们要保存寄存器？为什么内核要保存寄存器的原因，是因为内核即将要运行会覆盖这些寄存器的C代码。如果我们想正确的恢复用户程序，我们需要将这些寄存器恢复成它们在 ecall 调用之前的数值，所以我们需要将所有的寄存器都保存在 trapframe 中，这样才能在之后恢复寄存器的值。</p>
<p>另一个问题是，<strong>为什么这些寄存器保存在 trapframe，而不是用户代码的栈中？这个问题的答案是，我们不确定用户程序是否有栈，必然有一些编程语言没有栈，</strong>对于这些编程语言的程序，Stack Pointer不指向任何地址。当然，也有一些编程语言有栈，但是或许它的格式很奇怪，内核并不能理解。比如，编程语言以堆中以小块来分配栈，编程语言的运行时知道如何使用这些小块的内存来作为栈，但是内核并不知道。所以，如果我们想要运行任意编程语言实现的用户程序，内核就不能假设用户内存的哪部分可以访问，哪部分有效，哪部分存在。所以内核需要自己管理这些寄存器的保存，这就是为什么内核将这些内容保存在属于内核内存的trapframe中，而不是用户内存。</p>
</blockquote>
<p>程序现在仍然在trampoline的最开始，也就是 uservec 函数的最开始，我们基本上还没有执行任何内容。我在寄存器拷贝的结束位置设置了一个断点，我们在 gdb 中让代码继续执行，现在我们停在了下面这条 ld（load）指令。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104009495.png" alt="img"></p>
<p>这条指令正在将 a0 指向的内存地址往后数的第8个字节开始的数据加载到 Stack Pointer 寄存器。a0 的内容现在是trapframe page的地址，从本节第一张图中，trapframe 的格式可以看出，第 8 个字节开始的数据是内核的Stack Pointer（kernel_sp）。trapframe 中的 kernel_sp 是由 kernel 在进入用户空间之前就设置好的，它的值是这个进程的 kernel stack。所以这条指令的作用是初始化 Stack Pointer 指向这个进程的 kernel stack 的最顶端。指向完这条指令之后，我们打印一下当前的 Stack Pointer 寄存器，</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104045039.png" alt="img"></p>
<p>这是这个进程的 kernel stack。因为 XV6 在每个 kernel stack 下面放置一个 guard page，所以 kernel stack 的地址都比较大。</p>
<p>下一条指令是向 tp 寄存器写入数据。因为在 RISC-V 中，没有一个直接的方法来确认当前运行在多核处理器的哪个核上，XV6 会将 CPU 核的编号也就是 hartid 保存在 tp 寄存器。在内核中好几个地方都会使用了这个值，例如，内核可以通过这个值确定某个 CPU 核上运行了哪些进程。我们执行这条指令，并且打印 tp 寄存器。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104101258.png" alt="img"></p>
<p>我们现在运行在CPU核0，这说的通，因为我之前配置了QEMU只给XV6分配一个核，所以我们只能运行在核0上。</p>
<blockquote>
<p>tp 寄存器保存的是当前运行在哪个核中</p>
</blockquote>
<p>下一条指令是向 t0 寄存器写入数据。这里写入的是我们将要执行的第一个 C 函数的指针，也就是函数 usertrap 的指针。我们在后面会使用这个指针。</p>
<blockquote>
<p>向 t0 寄存器写入的是即将要执行的第一个 C 函数的指针</p>
</blockquote>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104155385.png" alt="img"></p>
<p>下一条指令是向 t1 寄存器写入数据。这里写入的是 kernel page table 的地址，我们可以打印 t1 寄存器的内容。</p>
<blockquote>
<p>t1 寄存器写入的是 kernel page table 的地址。</p>
</blockquote>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104210332.png" alt="img"></p>
<p>实际上严格来说，t1 的内容并不是 kernel page table 的地址，这是你需要向 SATP 寄存器写入的数据。它包含了 kernel page table 的地址，但是移位了（注，详见4.3），并且包含了各种标志位。</p>
<p>下一条指令是交换 SATP 和 t1 寄存器。这条指令执行完成之后，<strong>当前程序会从 user page table 切换到 kernel page table。</strong>现在我们在 QEMU 中打印 page table，可以看出与之前的 page table 完全不一样。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104239186.png" alt="img"></p>
<p>现在这里输出的是由内核设置好的巨大的 kernel page table。所以现在我们成功的切换了 page table，我们在这个位置进展的很好，Stack Pointer 指向了 kernel stack；我们有了 kernel page table，可以读取 kernel data。</p>
<p>我们已经准备好了执行内核中的C代码了。</p>
<p>这里还有个问题，为什么代码没有崩溃？毕竟我们在内存中的某个位置执行代码，程序计数器保存的是虚拟地址，如果我们切换了 page table，为什么同一个虚拟地址不会通过新的 page table 寻址走到一些无关的 page中？看起来我们现在没有崩溃并且还在执行这些指令。有人来猜一下原因吗？</p>
<blockquote>
<p>学生回答：因为我们还在 trampoline 代码中，而 trampoline 代码在用户空间和内核空间都映射到了同一个地址。</p>
<p>教授回答：完全正确，我不知道你们是否还记得 user page table 的内容，trampoline page在user page table中的映射与kernel page table中的映射是完全一样的。这两个page table中其他所有的映射都是不同的，只有trampoline page的映射是一样的，因此我们在切换page table时，寻址的结果不会改变，我们实际上就可以继续在同一个代码序列中执行程序而不崩溃。这是trampoline page的特殊之处，它同时在user page table和kernel page table都有相同的映射关系。</p>
</blockquote>
<p>之所以叫trampoline page，是因为你某种程度在它上面“弹跳”了一下，然后从用户空间走到了内核空间。</p>
<p>最后一条指令是 <code>jr t0</code> 。执行了这条指令，我们就要从 trampoline 跳到内核的C代码中。这条指令的作用是跳转到 t0 指向的函数中。我们打印 t0 对应的一些指令，</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104355536.png" alt="img"></p>
<p>可以看到 t0 的位置对应于一个叫做 usertrap 函数的开始。接下来我们就要以 kernel stack，kernel page table跳转到 usertrap 函数。</p>
<h3 id="usertrap-函数"><a href="#usertrap-函数" class="headerlink" title="usertrap 函数"></a>usertrap 函数</h3><p>usertrap函数是位于 <code>trap.c</code> 文件的一个函数。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104429488.png" alt="img"></p>
<p>既然我们已经运行在C代码中，接下来，我在gdb中输入 <code>tui enable</code> 打开对于 C 代码的展示。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104450725.png" alt="img"></p>
<p>有很多原因都可以让程序运行进入到 <code>usertrap</code> 函数中来，比如系统调用，运算时除以0，使用了一个未被映射的虚拟地址，或者是设备中断。<code>usertrap</code> 某种程度上存储并恢复硬件状态，但是它也需要检查触发 trap 的原因，以确定相应的处理方式，我们在接下来执行 usertrap 的过程中会同时看到这两个行为。</p>
<p>接下来，让我们一步步执行 usertrap 函数：</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104505409.png" alt="img"></p>
<p>它做的第一件事情是<strong>更改 STVEC 寄存器。</strong>取决于 trap 是来自于用户空间还是内核空间，实际上 XV6 处理 trap 的方法是不一样的。目前为止，我们只讨论过当 trap 是由用户空间发起时会发生什么。如果 trap 从内核空间发起，将会是一个非常不同的处理流程，因为从内核发起的话，程序已经在使用 kernel page table。所以当 trap 发生时，程序执行仍然在内核的话，很多处理都不必存在。</p>
<p>在内核中执行任何操作之前，usertrap 中先将 STVEC 指向了 kernelvec 变量，这是内核空间 trap 处理代码的位置，而不是用户空间 trap 处理代码的位置。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104548581.png" alt="img"></p>
<p>出于各种原因，我们需要知道当前运行的是什么进程，我们通过调用 myproc 函数来做到这一点。myproc 函数实际上会查找一个根据当前 CPU 核的编号索引的数组，CPU 核的编号是 hartid，如果你还记得，我们之前在uservec 函数中将它存在了 tp 寄存器。这是 myproc 函数找出当前运行进程的方法。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104616898.png" alt="img"></p>
<p>接下来我们要保存用户程序计数器，它仍然保存在 SEPC 寄存器中，但是可能发生这种情况：当程序还在内核中执行时，我们可能切换到另一个进程，并进入到那个程序的用户空间，然后那个进程可能再调用一个系统调用进而导致 SEPC 寄存器的内容被覆盖。所以，我们需要保存当前进程的 SEPC 寄存器到一个与该进程关联的内存中，这样这个数据才不会被覆盖。这里我们使用 trapframe 来保存这个程序计数器。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104752934.png" alt="img"></p>
<p>接下来我们需要找出我们现在会在 usertrap 函数的原因。根据触发 trap 的原因，RISC-V 的 SCAUSE 寄存器会有不同的数字。数字8表明，我们现在在 trap 代码中是因为系统调用。</p>
<blockquote>
<p>可以打印 SCAUSE 寄存器，它的确包含了数字8，我们的确是因为系统调用才走到这里的。</p>
</blockquote>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104812798.png" alt="img"></p>
<p>所以，我们可以进到这个 if 语句中。接下来第一件事情是检查是不是有其他的进程杀掉了当前进程，但是我们的 shell 没有被杀掉，所以检查通过。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104823029.png" alt="img"></p>
<p>在 RISC-V 中，存储在 SEPC 寄存器中的程序计数器，是用户程序中触发 trap 的指令的地址。但是当我们恢复用户程序时，我们希望在下一条指令恢复，也就是 ecall 之后的一条指令。所以对于系统调用，我们对于保存的用户程序计数器加 4，这样我们会在 ecall 的下一条指令恢复，而不是重新执行 ecall 指令。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104846355.png" alt="img"></p>
<p>XV6 会在处理系统调用的时候使能中断，这样中断可以更快的服务，有些系统调用需要许多时间处理。中断总是会被 RISC-V 的 trap 硬件关闭，所以在这个时间点，我们需要<strong>显式的打开中断。</strong></p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104917288.png" alt="img"></p>
<p>下一行代码中，我们会调用 syscall 函数。这个函数定义在 <code>syscall.c</code>。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304104928779.png" alt="img"></p>
<p>它的作用是从 syscall 表单中，根据系统调用的编号查找相应的系统调用函数。如果你还记得之前的内容，Shell 调用的 write 函数将 a7 设置成了系统调用编号，对于 write 来说就是 16。<strong>所以 syscall 函数的工作就是获取由 trampoline 代码保存在 trapframe 中 a7 的数字，然后用这个数字索引实现了每个系统调用的表单。</strong></p>
<p>我们可以打印 num ，发现的确是16。这与 Shell 调用的 write 函数写入的数字是一致的。之后查看通过 num 索引得到的函数，正是 sys_write 函数。sys_write 函数是内核对于 write 系统调用的具体实现。这里再往后的代码执行就非常复杂了，我就不具体介绍了。在这节课中，对于系统调用的实现，我只对进入和跳出内核感兴趣，这里我让代码直接执行 <code>sys_write</code> 函数。</p>
<p>这里有件有趣的事情，系统调用需要找到它们的参数。你们还记得 write 函数的参数吗？分别是文件描述符 2，写入数据缓存的指针，写入数据的长度 2。syscall 函数直接通过 trapframe 来获取这些参数，就像这里刚刚可以查看 trapframe 中的 a7 寄存器一样，我们可以查看 a0 寄存器，这是第一个参数，a1是第二个参数，a2是第三个参数。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304105043494.png" alt="img"></p>
<p>现在 syscall 执行了真正的系统调用，之后 sys_write 返回了。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304105057200.png" alt="img"></p>
<p>这里向 trapframe 中的 a0 赋值的原因是：所有的系统调用都有一个返回值，比如 write 会返回实际写入的字节数，<strong>而 RISC-V 上的C代码的习惯是函数的返回值存储于寄存器 a0，</strong>所以为了模拟函数的返回，我们将返回值存储在 trapframe 的 a0 中。之后，当我们返回到用户空间，trapframe 中的 a0 槽位的数值会写到实际的 a0 寄存器，Shell会认为 a0 寄存器中的数值是 write 系统调用的返回值。执行完这一行代码之后，我们打印这里 trapframe 中 a0 的值，可以看到输出 2。</p>
<p>这意味这 sys_write 的返回值是 2，符合传入的参数，这里只写入了 2个字节。从 syscall 函数返回之后，我们回到了 <code>trap.c</code> 中的 usertrap 函数。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304105139151.png" alt="img"></p>
<p>我们再次检查当前用户进程是否被杀掉了，因为我们不想恢复一个被杀掉的进程。当然，在我们的场景中，Shell没有被杀掉。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304105152631.png" alt="img"></p>
<p>最后，usertrap调用了一个函数 <code>usertrapret</code>。</p>
<h3 id="usertrapret-函数"><a href="#usertrapret-函数" class="headerlink" title="usertrapret 函数"></a>usertrapret 函数</h3><p>usertrap函数的最后调用了usertrapret函数，来设置好我之前说过的，在返回到用户空间之前内核要做的工作。我们可以查看这个函数的内容。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304105214655.png" alt="img"></p>
<p>它首先关闭了中断。我们之前在系统调用的过程中是打开了中断的，这里关闭中断是因为我们将要更新 STVEC 寄存器来指向用户空间的 trap 处理代码，而之前在内核中的时候，我们指向的是内核空间的 trap 处理代码（6.6）。<strong>我们关闭中断因为当我们将 STVEC 更新到指向用户空间的 trap 处理代码时，我们仍然在内核中执行代码。如果这时发生了一个中断，那么程序执行会走向用户空间的 trap 处理代码</strong>，即便我们现在仍然在内核中，出于各种各样具体细节的原因，这会导致内核出错。所以我们这里关闭中断。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304105308767.png" alt="img"></p>
<p>在下一行我们设置了 STVEC 寄存器指向 trampoline 代码，在那里最终会执行 sret 指令返回到用户空间。位于 trampoline 代码最后的 sret 指令会重新打开中断。这样，即使我们刚刚关闭了中断，当我们在执行用户代码时中断是打开的。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304105340881.png" alt="img"></p>
<p>接下来的几行填入了 trapframe 的内容，这些内容对于执行 trampoline 代码非常有用。这里的代码就是：</p>
<ul>
<li>存储了kernel page table的指针</li>
<li>存储了当前用户进程的kernel stack</li>
<li>存储了usertrap函数的指针，这样trampoline代码才能跳转到这个函数（注，详见6.5中 <em>ld t0 (16)a0</em> 指令）</li>
<li>从 tp 寄存器中读取当前的CPU核编号，并存储在trapframe中，这样trampoline代码才能恢复这个数字，因为用户代码可能会修改这个数字</li>
</ul>
<p>现在我们在usertrapret函数中，我们正在设置trapframe中的数据，这样下一次从用户空间转换到内核空间时可以用到这些数据。</p>
<blockquote>
<p>学生提问：为什么trampoline代码中不保存SEPC寄存器？</p>
<p>Robert教授：可以存储。trampoline代码没有像其他寄存器一样保存这个寄存器，但是我们非常欢迎大家修改XV6来保存它。如果你还记得的话（详见6.6），这个寄存器实际上是在C代码usertrap中保存的，而不是在汇编代码trampoline中保存的。我想不出理由这里哪种方式更好。用户寄存器（User Registers）必须在汇编代码中保存，因为任何需要经过编译器的语言，例如C语言，都不能修改任何用户寄存器。所以对于用户寄存器，必须要在进入C代码之前在汇编代码中保存好。但是对于SEPC寄存器（注，控制寄存器），我们可以早点保存或者晚点保存。</p>
</blockquote>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304105546413.png" alt="img"></p>
<p>接下来我们要设置 SSTATUS 寄存器，这是一个控制寄存器。这个寄存器的 SPP bit 位控制了 sret 指令的行为，该 bit 为 0 表示下次执行 sret 的时候，我们想要返回 user mode 而不是 supervisor mode。这个寄存器的 SPIE bit位控制了，在执行完 sret 之后，是否打开中断。因为我们在返回到用户空间之后，我们的确希望打开中断，所以这里将 SPIE bit 位设置为1。修改完这些 bit 位之后，我们会把新的值写回到 SSTATUS 寄存器。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304105638012.png" alt="img"></p>
<p>我们在 trampoline 代码的最后执行了sret指令。这条指令会将程序计数器设置成 SEPC 寄存器的值，所以现在我们将 SEPC 寄存器的值设置成之前保存的用户程序计数器的值。在不久之前，我们在 usertrap 函数中将用户程序计数器保存在trapframe中的epc字段。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304105707488.png" alt="img"></p>
<p>接下来，我们根据user page table地址生成相应的SATP值，这样我们在返回到用户空间的时候才能完成page table的切换。实际上，我们会在汇编代码trampoline中完成page table的切换，并且也只能在trampoline中完成切换，因为只有trampoline中代码是同时在用户和内核空间中映射。但是我们现在还没有在trampoline代码中，我们现在还在一个普通的C函数中，所以这里我们将page table指针准备好，并将这个指针作为第二个参数传递给汇编代码，这个参数会出现在a1寄存器。</p>
<p>倒数第二行的作用是计算出我们将要跳转到汇编代码的地址。我们期望跳转的地址是tampoline中的userret函数，这个函数包含了所有能将我们带回到用户空间的指令。所以这里我们计算出了userret函数的地址。</p>
<p>倒数第一行，将fn指针作为一个函数指针，执行相应的函数（也就是userret函数）并传入两个参数，两个参数存储在a0，a1寄存器中。</p>
<h3 id="userret-函数"><a href="#userret-函数" class="headerlink" title="userret 函数"></a>userret 函数</h3><p>现在程序执行又到了trampoline代码。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304105840754.png" alt="img"></p>
<p>第一步是切换page table。在执行 <code>csrw satp, a1</code> 之前，page table应该还是巨大的kernel page table。这条指令会将user page table（在usertrapret中作为第二个参数传递给了这里的userret函数，所以存在a1寄存器中）存储在SATP寄存器中。执行完这条指令之后，page table就变成了小得多的user page table。但是幸运的是，user page table也映射了trampoline page，所以程序还能继续执行而不是崩溃。（注，sfence.vma是清空页表缓存，详见4.4）。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304105932915.png" alt="img"></p>
<p>在uservec函数中，第一件事情就是交换SSRATCH和a0寄存器。而这里，我们将 SSCRATCH 寄存器恢复成保存好的用户的a0寄存器。在这里 a0 是trapframe的地址，因为C代码usertrapret函数中将trapframe地址作为第一个参数传递过来了。112是a0寄存器在trapframe中的位置。（注，这里有点绕，本质就是通过当前的a0寄存器找出存在trapframe中的a0寄存器）我们先将这个地址里的数值保存在t0寄存器中，之后再将t0寄存器的数值保存在SSCRATCH寄存器中。</p>
<p>目前为止，所有的寄存器内容还是属于内核。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304110045221.png" alt="img"></p>
<p>接下来的这些指令将 a0 寄存器指向的 trapframe 中，之前保存的寄存器的值加载到对应的各个寄存器中。之后，我们离能真正运行用户代码就很近了。</p>
<blockquote>
<p>学生提问：现在 trapframe 中的 a0 寄存器是我们执行系统调用的返回值吗？</p>
<p>Robert教授：是的，系统调用的返回值覆盖了我们保存在 trapframe 中的 a0 寄存器的值（详见6.6）。我们希望用户程序 Shell 在 a0 寄存器中看到系统调用的返回值。所以，trapframe 中的 a0 寄存器现在是系统调用的返回值 2。相应的 SSCRATCH 寄存器中的数值也应该是 2，可以通过打印寄存器的值来验证。</p>
</blockquote>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304110411221.png" alt="img"></p>
<p>现在我们打印所有的寄存器，</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304110421371.png" alt="img"></p>
<p>我不确定你们是否还记得，但是这些寄存器的值就是我们在最最开始看到的用户寄存器的值。例如SP寄存器保存的是user stack地址，这是一个在较小的内存地址；a1寄存器是我们传递给write的buffer指针，a2是我们传递给write函数的写入字节数。</p>
<p>a0 寄存器现在还是个例外，它现在仍然是指向 trapframe 的指针，而不是保存了的用户数据。</p>
<p>接下来，在我们即将返回到用户空间之前，我们交换SSCRATCH寄存器和a0寄存器的值。前面我们看过了SSCRATCH现在的值是系统调用的返回值2，a0寄存器是trapframe的地址。交换完成之后，a0持有的是系统调用的返回值，SSCRATCH持有的是trapframe的地址。之后trapframe的地址会一直保存在SSCRATCH中，直到用户程序执行了另一次trap。现在我们还在kernel中。</p>
<p>sret是我们在kernel中的最后一条指令，当我执行完这条指令：</p>
<ul>
<li>程序会切换回 user mode；</li>
<li>SEPC 寄存器的数值会被拷贝到 PC 寄存器（程序计数器）；</li>
<li>重新打开中断。</li>
</ul>
<p>现在我们回到了用户空间，打印PC寄存器：</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304110453852.png" alt="image-20220304110453852"></p>
<p>这是一个较小的指令地址，非常像是在用户内存中。如果我们查看 <code>sh.asm</code>，可以看到这个地址是 write 函数的 ret 指令地址。</p>
<p><img src="https://blog-img-acking.oss-cn-beijing.aliyuncs.com/img/image-20220304110507023.png" alt="img"></p>
<p>所以，现在我们回到了用户空间，执行完 ret 指令之后我们就可以从 write 系统调用返回到 shell 中了。或者更严格的说，是从触发了系统调用的 write 库函数中返回到 shell 中。</p>
<p>总结一下，系统调用被刻意设计的看起来像是函数调用，但是背后的 user&#x2F;kernel 转换比函数调用要复杂的多。之所以这么复杂，很大一部分原因是要保持 user&#x2F;kernel 之间的隔离性，内核不能信任来自用户空间的任何内容。</p>
<p>另一方面，XV6 实现 trap 的方式比较特殊，XV6 并不关心性能。但是通常来说，操作系统的设计人员和 CPU 设计人员非常关心如何提升 trap 的效率和速度。必然还有跟我们这里不一样的方式来实现 trap，当你在实现的时候，可以从以下几个问题出发：</p>
<ul>
<li>硬件和软件需要协同工作，你可能需要重新设计 XV6，重新设计 RISC-V 来使得这里的处理流程更加简单，更加快速。</li>
<li>另一个需要时刻记住的问题是，恶意软件是否能滥用这里的机制来打破隔离性。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/mit6-s081/" rel="tag"># mit6.s081</a>
              <a href="/tags/OS/" rel="tag"># OS</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/01/28/ch08/" rel="prev" title="mit6.s081-ch8">
      <i class="fa fa-chevron-left"></i> mit6.s081-ch8
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/01/28/ch04/" rel="next" title="mit6.s081-ch4">
      mit6.s081-ch4 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-6-isolation-amp-syscall"><span class="nav-number">1.</span> <span class="nav-text">Chapter 6 isolation &amp; syscall</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Trap-%E6%9C%BA%E5%88%B6"><span class="nav-number">1.0.1.</span> <span class="nav-text">Trap 机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E5%92%8C%E9%9A%94%E7%A6%BB"><span class="nav-number">1.0.1.1.</span> <span class="nav-text">安全和隔离</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Trap-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.0.2.</span> <span class="nav-text">Trap 代码执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ECALL-%E6%8C%87%E4%BB%A4%E4%B9%8B%E5%89%8D%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">1.0.3.</span> <span class="nav-text">ECALL 指令之前的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ECALL-%E6%8C%87%E4%BB%A4%E4%B9%8B%E5%90%8E%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">1.0.4.</span> <span class="nav-text">ECALL 指令之后的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#uservec-%E5%87%BD%E6%95%B0"><span class="nav-number">1.0.5.</span> <span class="nav-text">uservec 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#usertrap-%E5%87%BD%E6%95%B0"><span class="nav-number">1.0.6.</span> <span class="nav-text">usertrap 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#usertrapret-%E5%87%BD%E6%95%B0"><span class="nav-number">1.0.7.</span> <span class="nav-text">usertrapret 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#userret-%E5%87%BD%E6%95%B0"><span class="nav-number">1.0.8.</span> <span class="nav-text">userret 函数</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sam Shen"
      src="/uploads/1.jpg">
  <p class="site-author-name" itemprop="name">Sam Shen</p>
  <div class="site-description" itemprop="description">share cs knowledge</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sam Shen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
